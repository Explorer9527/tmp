// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.28;
import "./StrucksTest";
/*
1.定义
    Solidity 中使用 struct 关键字定义结构体，可以将多种数据类型组合在一起形成自定义的复合数据类型。
    结构体是 Solidity 中管理复杂数据的强大工具，合理设计和使用结构体可以显著提高智能合约的灵活性和可维护性。
2.结构体的常见应用场景
    用户信息管理：可以使用结构体存储用户的详细信息，如姓名、年龄、得分等。
    订单管理：在电商合约中，结构体可以用于存储订单的详细信息，如订单ID、产品列表、总价等。
3.结构体的限制
    不能包含自身类型作为成员：结构体不能直接包含其自身类型作为成员，但可以通过映射来间接包含。
    在设计合约时，需要根据实际需求选择适当的结构体成员和初始化方式，并考虑到结构体的限制。
4.结构体的最佳实践总结：
    结构体命名与设计：结构体的名称应当具有描述性，成员字段名称应简洁且易于理解。避免结构体过于复杂，以免影响合约的可维护性。
    减少存储成本：尽量减少结构体中存储的字段数量，以优化存储成本，尤其在频繁更新的场景下可以考虑使用指针（引用）。
    避免嵌套复杂性：结构体的嵌套使用虽然灵活，但过度嵌套可能导致合约代码复杂度增加，应谨慎设计。
*/
contract StructType {
    //1.定义结构体
    struct A{//基本形式
        uint8 x;
        string y;
    }
    struct B{//复杂形式
        A[] aa;
        mapping(int => bool) m1;
        mapping(int => A) m2;//注意A不能放在key的位置
        string n;
    }
    struct C{//不能包含自身类型作为成员：结构体不能直接包含其自身类型作为成员，但可以通过映射来间接包含。
        mapping(int => C) self;
        string n;
    }
    //2.初始化
    A ta1;//默认初始值
    A ta2 = A(1,"2");//状态变量初始化
    A ta3 = A({x:1,y:"2"},{x:3,y:"4"});//具名方式初始化：这种方式不需要按照成员顺序，可以自由选择初始化的顺序，但必须忽略mapping类型的成员。
    C ta3 = C("s");//对于包含mapping的结构体，只能对非mapping成员进行初始化。
    //3.使用
    B bt;
    function test() public{
        bt.n = "123";
        bt.aa[0].x = 1;
    }
    //4.引用结构体:import "./StrucksTest";
    ST[] public ssss;
}